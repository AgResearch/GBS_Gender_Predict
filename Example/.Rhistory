rm(list=ls())
1/(4*(2*alpha+1))
alpha=1
1/(4*(2*alpha+1))
plot(dbeta(x, shape1 = alpha, shape2 = alpha),x)
x=seq(0,1,0.1)
x=seq(0,1,0.01)
plot(dbeta(x, shape1 = alpha, shape2 = alpha),x)
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x)
alpha=0.5
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x)
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))))
max(dbeta(x, shape1 = alpha, shape2 = alpha))
x=seq(0.01,0.99,0.01)
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))))
alpha=0.75
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))))
alpha=0.1
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))))
alpha=0.8
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))))
alpha=0.3
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))))
plot(dbeta(x, shape1 = alpha, shape2 = alpha)~x, ylim=c(0,max(dbeta(x, shape1 = alpha, shape2 = alpha))), type="l")
1/(4*(2*alpha+1))
alpha =  0   # Double reduction parameter
epsilon = 0.01 # sequencing error parameter
nSires <- 20   # Number of sires
nDams <- 5     # Number of dams per sire
nProg <- 2     # Number of progeny for each pair of parents
nSelf <- 1     # Number of progeny from mating of siblings
nInd <- nSires+(nDams*nSires)*(1+nProg)+ nSelf*choose(nProg,2)*nDams*nSires # Number of individuals in total
nSnps <- 10000  # number of SNPs
ploid <- 2
meanDepth <- 5
#nRuns = 100
#nClust = 8
# sort out structure of the population
#matrix(sapply(1:nSires,function(x) rbind(rep(x,nDams), 20+(1:nDams)+(x-1)*5)), ncol=2,byrow=T)
sirepos <- as.vector(sapply(1:nSires,rep,times=nDams*nProg))
dampos <- as.vector(sapply(1:(nDams*nSires) + nSires,rep,times=nProg))
progpos <- 1:(nProg*nDams*nSires) + nSires + nDams*nSires
# index the siblings in the
uSib <- matrix(dampos,nrow=nProg*nDams*nSires,ncol=nProg*nDams*nSires) ==  matrix(dampos,nrow=nProg*nDams*nSires,ncol=nProg*nDams*nSires,byrow=T)
uSib[lower.tri(uSib)] <- F
diag(uSib) <- F
uSib <- which(uSib,arr.ind=T) + nSires + nDams*nSires
sibpos <- max(uSib)+1:nrow(uSib)
## index which individuals should have the same self-relatedness value
sr1 <- 1:((nDams*nSires) + nSires)
sr2 <- max(sr1) + 1:(nProg*nDams*nSires)
sr3 <- max(sr2)+1:(length(sr2)/2)
## index which individuals should have the same relatedness value
library(AGHmatrix)
ped <- cbind(1:(nSires*nDams+nSires),rep(0,nSires*nDams+nSires),rep(0,nSires*nDams+nSires))
ped <- rbind(ped, cbind(progpos,sirepos,dampos))
ped <- rbind(ped, cbind(sibpos,uSib))
colnames(ped) <- c("Ind","Par1","Par2")
ped <- as.data.frame(ped)
for(i in 1:ncol(ped))
ped[,i] <- factor(ped[,i])
Amat <- Amatrix(ped, ploidy = 2*ploid, w=alpha)
tab <- table(Amat)[1:4]
rr1 <- which(Amat == names(tab)[1], arr.ind=T)
rr1 <- rr1[-which(rr1[,2] < rr1[,1]),]
rr2 <- which(Amat == names(tab)[2], arr.ind=T)
rr2 <- rr2[-which(rr2[,2] < rr2[,1]),]
rr3 <- which(Amat == names(tab)[3], arr.ind=T)
rr3 <- rr3[-which(rr3[,2] < rr3[,1]),]
rr4 <- which(Amat == names(tab)[4], arr.ind=T)
rr4 <- rr4[-which(rr4[,2] < rr4[,1]),]
tab <- as.numeric(c(names(tab)[1:4], Amat[sr1[1],sr1[1]], Amat[sr2[1],sr2[1]], Amat[sr3[1],sr3[1]] ))
run=1
set.seed(run*39)
## simulate the minor allele frequencies for each SNP
p <- runif(n = nSnps, min=0, max = 1)
## List of Computed G matrices
Gmat <- vector(mode = "list", length=0)
samGeno <- function(x) sum(sample(x=c(rep(1,x),rep(0,2*ploid-x)),size=ploid))
samGeno <- Vectorize(samGeno)
### Simulate the parents genotypes
geno_par <- matrix(rbinom((nSires+nDams*nSires)*nSnps,2*ploid,p),ncol=nSnps,byrow=T)
### simulate the progeny's genotype
# simulate genotypes for progeny from parents
geno_prog <- matrix(samGeno(geno_par[sirepos,]), ncol=nSnps) + matrix(samGeno(geno_par[dampos,]), ncol=nSnps)
# simulate genotypes from progeny of sibling mating
geno_sib <- matrix(samGeno(geno_prog[uSib[,1]-nSires - nDams*nSires,]), ncol=nSnps) +
matrix(samGeno(geno_prog[uSib[,2]-nSires - nDams*nSires,]), ncol=nSnps)
## Combine genos
geno <- rbind(geno_par,geno_prog, geno_sib)
## simulation the GBS data:
depth <- matrix(rnbinom(nInd*nSnps,mu=meanDepth, size=2*ploid),ncol=nSnps)
Acounts <- matrix(rbinom(nInd*nSnps,depth,geno/(2*ploid)),ncol=nSnps)
genoGBS <- (2*ploid)*Acounts/depth
## simulate the errors
Bcounts <- depth - Acounts
aCountsFinal <- matrix(rbinom(nInd*nSnps,Acounts,prob=1-epsilon),ncol=nSnps) + matrix(rbinom(nInd*nSnps,Bcounts,prob=epsilon),ncol=nSnps)
genoGBS_ep <- (2*ploid)*aCountsFinal/depth
genoGBS_filt <- genoGBS
genoGBS_filt[which(depth < 3)] <- NA
temp < diag(tcrossprod(geno))/10000
temp <- diag(tcrossprod(geno))/10000
str(temp)
temp <- diag(tcrossprod(geno-ploid))/10000
str(temp)
tail(temp)
str((2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))))
alpha=1
str((2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))))
temp <- 2/(2*ploid)^2*diag(tcrossprod(geno-ploid))/10000
str(temp)
str((2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))))
hist((2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))))
hist((2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))), breaks=100)
hist(p)
hist((2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))) + 1, breaks=100)
tt <- (2*ploid*temp-1)/(1/2 - 1/(2*(2*alpha+1))) + 1
snpsubset <- which(p < 1 & p > 0)
nsnpsub <- length(snpsubset)
psub <- p[snpsubset]
Gmat$Geno <- tcrossprod(geno[,snpsubset]-(2*ploid)*rep.int(psub,rep(nrow(geno),nsnpsub)))/(2*ploid*sum(psub*(1-psub)))
plot(diag(Gmat$Geno),tt)
abline(0,1)
2/(2*ploid)^2*temp2 <- tcrossprod(geno-ploid)/10000
temp2  <- 2/(2*ploid)^2*tcrossprod(geno-ploid)/10000
(tt2 <- temp2+1/2)/(1/2-1/(2*(2*alpha+1)))
tt2 <- (temp2+1/2)/(1/2-1/(2*(2*alpha+1)))
str(temp2)
hist(temp2)
tt2 <- (temp2-1/2)/(1/2-1/(2*(2*alpha+1)))
hist(temp2)
hist(tt2)
tt2 <- (temp2+1/2)/(1/2-1/(2*(2*alpha+1)))
hist(tt2)
tt2 <- (temp2-1/4)/(1/2-1/(2*(2*alpha+1)))
hist(tt2)
tt2 <- (temp2)/(1/2-1/(2*(2*alpha+1)))
hist(tt2)
tt2 <- (temp2)/(1/2-1/(2*(2*alpha+1)))-1/2
hist(tt2)
hist(tt2, breaks=100)
tt2 <- (2*ploid)*((temp2)/(1/2-1/(2*(2*alpha+1)))-1/2)
hist(tt2, breaks=100)
tt2 <- (ploid)*((temp2)/(1/2-1/(2*(2*alpha+1)))-1/2)
hist(tt2, breaks=100)
tt2 <- (2*ploid)*((temp2)/(1/2-1/(2*(2*alpha+1)))-1/2)
plot(tt2[upper.tri(tt2)], Gmat$Geno[upper.tri(Gmat$Geno)])
abline(0,1)
### Case 4: (Weir with true genotypes)
Gmat$Weir <- calcGRM_weir(geno)
calcGRM_weir <- function(geno, depth=NULL, ep=NULL){
if(!is.null(ep) & !is.null(depth)){
geno[which(depth < 2)] <- NA
snpsubset <- which(!(colMeans(geno, na.rm=T) %in% c(0, 2*ploid)))
geno <- geno[, snpsubset]
na_indx <- !is.na(geno)
na_mat <- tcrossprod(na_indx,na_indx)
#geno0 <- geno
geno[which(is.na(geno))] <- ploid
#geno0[which(is.na(geno0))] <- 0
drat <- 1/depth[,snpsubset]
drat[which(depth[,snpsubset] < 2)] <- 0
epMat <- matrix(ep, nrow=nrow(geno), ncol=ncol(geno))
epMat[which(depth[,snpsubset] < 2)] <- 0
mat <- 1/2 + 2/(2*ploid)^2*(tcrossprod((geno-ploid)/sqrt(1-4*epMat*(1-epMat))) -
tcrossprod(sqrt((((2*ploid)^2/4)*na_indx)/(1-4*epMat*(1-epMat)))) + tcrossprod(sqrt((2*ploid)^2/4*na_indx)) +
tcrossprod(sqrt((2*ploid)^2*epMat*(1-epMat)/(1-4*epMat*(1-epMat)))))/na_mat
diag(mat) <- 1/2 + 2/(2*ploid)^2*rowSums( (((geno-ploid)^2 - (2*ploid)^2/4)/(1-drat) + (2*ploid)^2*epMat*(1-epMat))/(1-4*epMat*(1-epMat)) + (2*ploid)^2/4)/diag(na_mat)
#Si <- rowSums(geno/(1-4*epMat*(1-epMat)))
#shi_sum <- matrix(Si, nrow=length(Si), ncol=length(Si)) + matrix(Si, nrow=length(Si), ncol=length(Si), byrow=T)
#mat <- 1 + 2/(2*ploid)^2*( tcrossprod((geno-ploid)/(sqrt(1-4*epMat*(1-epMat)))) -
#                               tcrossprod(sqrt((2*ploid)^2/4*na_indx/(1-4*epMat*(1-epMat)))) +
#                               tcrossprod(sqrt((2*ploid)^2*epMat*(1-epMat))))/na_mat
#mat <- 1 + 2/(2*ploid)^2*( tcrossprod(geno/sqrt(1-4*epMat*(1-epMat))) - ploid*(shi_sum) + tcrossprod(sqrt((2*ploid)^2*epMat*(1-epMat))))/na_mat
#diag(mat) <- 1 + 2/(2*ploid)^2*rowSums( ((geno0^2 - (2*ploid)*geno0)/(1-4*epMat*(1-epMat)) + (2*ploid)^2*epMat*(1-epMat))/(1-drat) )/diag(na_mat)
#diag(mat) <- 1/2 + 2/(2*ploid)^2*rowSums( (((geno-ploid)^2 - (2*ploid)^2/4)/(1-4*epMat*(1-epMat)) + (2*ploid)^2*epMat*(1-epMat))/(1-drat) + (2*ploid)^2/4)/diag(na_mat)
}
else if(!is.null(depth)){
geno[which(depth < 2)] <- NA
snpsubset <- which(!(colMeans(geno, na.rm=T) == 2*ploid))
geno <- geno[, snpsubset]
na_mat <- !is.na(geno)
na_mat <- tcrossprod(na_mat,na_mat)
geno[which(is.na(geno))] <- ploid
drat <- 1/depth[,snpsubset]
drat[which(depth[,snpsubset] < 2)] <- 0
mat <- 1/2 + 2/(2*ploid)^2*tcrossprod(geno - ploid)/na_mat
diag(mat) <- 1/2 + 2/(2*ploid)^2*rowSums(((geno-ploid)^2 - (2*ploid)^2/4)/(1-drat) + (2*ploid)^2/4)/diag(na_mat)
} else{
snpsubset <- which(!(colMeans(geno, na.rm=T) == 2*ploid))
geno <- geno[, snpsubset]
nSnps = length(snpsubset)
na_mat <- !is.na(geno)
na_mat <- tcrossprod(na_mat,na_mat)
geno[which(is.na(geno))] <- ploid
mat <- 1/2 + 2/(2*ploid)^2*tcrossprod(geno - ploid)/na_mat
}
mat_sum <- (sum(mat) - sum(diag(mat)))/(nrow(mat)*(nrow(mat)-1))
GRM_weir <- 2*ploid*(mat - mat_sum)/(1-mat_sum)
return(GRM_weir)
}
### Case 4: (Weir with true genotypes)
Gmat$Weir <- calcGRM_weir(geno)
plot(tt2[upper.tri(tt2)], Gmat$Weir[upper.tri(Gmat$Geno)])
abline(0,1)
tt2 <- (2*ploid)*((temp2)/(1/2+1/(2*(2*alpha+1)))-1/2)
hist(tt2)
tt2 <- (2*ploid)*((temp2)/(1/2+1/(2*(2*alpha+1))))
hist(tt2)
temp2 <- (tcrossprod(geno)/10000 +1/4)/(1/4 - 1/(4*(2*alpha+1)))
hist(tt2)
hist(tt2/(2*ploid))
hist(tt2/(2*ploid)-1/4)
plot(Gmat$Geno[upper.tri(Gmat$Geno)], tt2[upper.tri(tt2)])
abline(0,1)
hist(tt2/(2*ploid)-1/4)
hist(tt2/(2*ploid)-1/4, breaks=100)
hist((2*ploid)*(tt2/(2*ploid)-1/4), breaks=100)
hist(temp2)
(tcrossprod(geno)/10000 +1/4)/(1/4 - 1/(4*(2*alpha+1)))
str(tcrossprod(geno)/10000)
str(tcrossprod(geno)/(10000*(2*ploid)^2))
str(tcrossprod(geno)/(10000*(2*ploid)^2)-1/(4*(2*alpha+1)))
m <- 1/2 + 1/(4*(2*alpha+1))
str(tcrossprod(geno)/(10000*(2*ploid)^2)-m)
m <- 1/2 - 1/(4*(2*alpha+1))
str(tcrossprod(geno)/(10000*(2*ploid)^2)-m)
hist(tcrossprod(geno)/(10000*(2*ploid)^2)-m)
m <- 1/4 + 1/(4*(2*alpha+1))
hist(tcrossprod(geno)/(10000*(2*ploid)^2)-m)
hist(tcrossprod(geno)/(10000*(2*ploid)^2)-m, breaks=100)
hist((tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m, breaks=100)
hist((tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m*(2*ploid), breaks=100)
hist((tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m*(2*ploid)^2, breaks=100)
hist((tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m*(2*ploid), breaks=100)
temp2 <- (tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m*(2*ploid)
m2 <- 1/4 - 1/(4*(2*alpha+1))
temp2 <- (tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m2*(2*ploid)
hist(temp2)
hist(temp2, breaks=100)
plot(temp2[upper.tri(temp2)], Gmat$Geno[upper.tri(Gmat$Geno)])
abline(0m1)
abline(0,1)
plot(temp2[upper.tri(temp2)], Gmat$Weir[upper.tri(Gmat$Geno)])
abline(0,1)
pot(diag(temp2))
hist(diag(temp2))
hist(diag(temp2), breaks=100)
plot(diag(temp2),diag(Gmat$Geno))
abline(0,1)
calcGRM_new2 <- function(geno, alpha=1){
m2 <- 1/4 - 1/(4*(2*alpha+1))
m <- 1/4 + 1/(4*(2*alpha+1))
return((tcrossprod(geno)/(10000*(2*ploid)^2)-m)/m2*(2*ploid))
}
set.seed(run*39)
## simulate the minor allele frequencies for each SNP
p <- runif(n = nSnps, min=0.5, max = 1)
## List of Computed G matrices
Gmat <- vector(mode = "list", length=0)
samGeno <- function(x) sum(sample(x=c(rep(1,x),rep(0,2*ploid-x)),size=ploid))
samGeno <- Vectorize(samGeno)
### Simulate the parents genotypes
geno_par <- matrix(rbinom((nSires+nDams*nSires)*nSnps,2*ploid,p),ncol=nSnps,byrow=T)
### simulate the progeny's genotype
# simulate genotypes for progeny from parents
geno_prog <- matrix(samGeno(geno_par[sirepos,]), ncol=nSnps) + matrix(samGeno(geno_par[dampos,]), ncol=nSnps)
# simulate genotypes from progeny of sibling mating
geno_sib <- matrix(samGeno(geno_prog[uSib[,1]-nSires - nDams*nSires,]), ncol=nSnps) +
matrix(samGeno(geno_prog[uSib[,2]-nSires - nDams*nSires,]), ncol=nSnps)
## Combine genos
geno <- rbind(geno_par,geno_prog, geno_sib)
## simulation the GBS data:
depth <- matrix(rnbinom(nInd*nSnps,mu=meanDepth, size=2*ploid),ncol=nSnps)
Acounts <- matrix(rbinom(nInd*nSnps,depth,geno/(2*ploid)),ncol=nSnps)
genoGBS <- (2*ploid)*Acounts/depth
## simulate the errors
Bcounts <- depth - Acounts
aCountsFinal <- matrix(rbinom(nInd*nSnps,Acounts,prob=1-epsilon),ncol=nSnps) + matrix(rbinom(nInd*nSnps,Bcounts,prob=epsilon),ncol=nSnps)
genoGBS_ep <- (2*ploid)*aCountsFinal/depth
genoGBS_filt <- genoGBS
genoGBS_filt[which(depth < 3)] <- NA
snpsubset <- which(p < 1 & p > 0)
nsnpsub <- length(snpsubset)
psub <- p[snpsubset]
Gmat$Geno <- tcrossprod(geno[,snpsubset]-(2*ploid)*rep.int(psub,rep(nrow(geno),nsnpsub)))/(2*ploid*sum(psub*(1-psub)))
tt <- calcGRM_new2(geno)
hist(tt)
### Case 9: (GBS with weir)
Gmat$GBS_Weir <- calcGRM_weir(genoGBS, depth)
hist(diag(Gmat$GBS_Weir))
hist(diag(Gmat$GBS_Weir), breaks=100)
35720+19631+10788+5929+3258+1791+984+541+297+163+90+49+27+15+8+5+2
27536+15381+8592+4799+2681+1497+836+467+261+146+81+45+25+14+8+4+2
20*0.1 + 0.2
20*0.1^2 + 0.2
17*(20*0.1^2 + 0.2)
17*(20*0^2 + 0.2)
rm(list=ls())
setwd("C:/Users/biltont/OneDrive - AgResearch/GBS_Gender_Prediction/GitHub/Scripts")
source('C:/Users/biltont/OneDrive - AgResearch/GBS_Gender_Prediction/GitHub/Scripts/find_SNPs_function.R')
setwd("../Example/")
debug(finding_SNPs)
SNP_positions <- "../Data/SNP_positions.csv"
deer_tagdigger <- "../Data/deer_tagdigger.csv"
deer_count <- "../Data/deer_count.csv"
sampleID <- "../Data/Train.csv"
finding_SNPs(SNP_positions,deer_tagdigger,deer_count,sampleID,output="./")
SNP_pos_X<-sex_markers$SNP_position[index_X_SNPs] #creates vector with X SNP positions
male_SNP_X_hetero<-apply(genon[male_rows,index_X_SNPs],2,function(x) sum(x=="1")/length(male_rows)) #calculates the heterozygosity the SNPs have with males, should be low
male_and_X<-data.frame(male_SNP_X_hetero,SNP_pos_X) #create dataframe
male_and_X<-male_and_X[order(male_and_X$SNP_pos_X),] #orders the SNP positions smallest to largest
plot(male_and_X$SNP_pos_X, male_and_X$male_SNP_X_hetero, xlab="X chr position", ylab="prprtn heterozygosity X chr", pch=19,cex.lab=1.5,cex.axis=1.5)
par(mfrow=c(1,2), mar=c(6.6,4.6,2,1))
plot(male_and_X$SNP_pos_X/(1e6), male_and_X$male_SNP_X_hetero, xlab="X Position (Mb)",
ylab="Heterozygosity (X chr)", pch=19,cex.lab=1.5,cex.axis=1.5)
abline(v=170, col=2, lwd=2)
abline(h=0, lty=2)
abline(h=0.1,col=2, lwd=2, lty=2)
mtext("(a)", side=1, line=5,cex=1.5)
plot(modified_male_and_X$modified_SNP_pos_X/(1e6), modified_male_and_X$modified_male_SNP_X_hetero, xlab="X Position (Mb)", ylab="Heterozygosity (X chr)", ylim=c(0,0.7175573),main="",pch=19,cex.lab=1.5,cex.axis=1.5)
modified_SNP_pos_X<-modified_sex_markers$SNP_position[modified_index_X_SNPs]
modified_male_SNP_X_hetero<-apply(modified_genon[male_rows,modified_index_X_SNPs],2,function(x) sum(x=="1")/length(male_rows))
modified_male_and_X<-data.frame(modified_male_SNP_X_hetero,modified_SNP_pos_X)
modified_male_and_X<-modified_male_and_X[order(modified_male_and_X$modified_SNP_pos_X),] #orders the SNP positions smallest to largest
plot(modified_male_and_X$modified_SNP_pos_X/(1e6), modified_male_and_X$modified_male_SNP_X_hetero, xlab="X Position (Mb)", ylab="Heterozygosity (X chr)", ylim=c(0,0.7175573),main="",pch=19,cex.lab=1.5,cex.axis=1.5)
abline(h=0, lty=2)
mtext("(b)", side=1, line=5,cex=1.5)
png("FigureS1.png",width=12*300,height=6*300, type='cairo', res=300)
par(mfrow=c(1,2), mar=c(6.6,4.6,2,1))
plot(male_and_X$SNP_pos_X/(1e6), male_and_X$male_SNP_X_hetero, xlab="X Position (Mb)",
ylab="Heterozygosity (X chr)", pch=19,cex.lab=1.5,cex.axis=1.5)
abline(v=170, col=2, lwd=2)
abline(h=0.1,col=2, lwd=2, lty=2)
abline(h=0, lty=2)
mtext("(a)", side=1, line=5,cex=1.5)
plot(modified_male_and_X$modified_SNP_pos_X/(1e6), modified_male_and_X$modified_male_SNP_X_hetero, xlab="X Position (Mb)", ylab="Heterozygosity (X chr)", ylim=c(0,0.7175573),main="",pch=19,cex.lab=1.5,cex.axis=1.5)
abline(h=0, lty=2)
mtext("(b)", side=1, line=5,cex=1.5)
dev.off()
getwd()
q()
q()
